    """Your README.md file should be minimally multiple paragraphs in length, and should explain what your project is, what each of the files you wrote for the project contains and does, and if you debated certain design choices, explaining why you made them. Ensure you allocate sufficient time and energy to writing a README.md that documents your project thoroughly. Be proud of it! If it is too short, the system will reject it."""
    # PARKOUR
    #### Video Demo:  <URL HERE>
    #### Description:
    A platformer 2d game where the objective it to climb as high as you can, inspired by the 2001 game icy tower by Johanz Pietz and a favourite childhood game of mine. The game's name was taken as a parody from the episode in the famous tv show called The Office(US version not the Brithsh), where main characters Micheal Scott and Dwight Schrute were jumping off off furnitures and screaming parkour. The character design is based on Micheal Scott in that episode. All sprites and designs were made by me, but I do not have ownership of the character in my game, and was just made for the fun of it. The platforms were designed after the 4 elements fire, water, earth and air.

    The game features the character in a tower like enviroment, the user uses the directional keys left and right to move the character left and right, and the space key to jump. The character can reach higher platforms by gaining some speed before jumping, and can bounce off walls to gain speed as well. As the player progresses higher the platforms change elements, once reaching the last element it order of elements starts all over again. The game starts with following the character as they go up, but after a certain threshold a timer is activated and the screen starts scrolling up on its own, every second it will gradually scroll a bit more until it reaches a max scroll
    speed. The player then needs to just go as high as they can to get a highscore. Player can play multiple times to try and beat previous score. 

    Parkour is made with the 2d game engine library called pygame, and the python physics engine pymunk which was integrated from the C library chimpmunk. Pygame handles the gui display screen, the main menu, control menu, keyinput, exiting and sprites. Pymunk hands all the objects in the surface(display)of pygame which are the walls, platforms and the character, pymunk is also responsible for the physics of the game, such as the gravity, collision between the character and the platform. 
    
    Pymunk allows us to use the special collision handlers to toggle on and of depending on the characters current state, it also allows something called a sensor, which I implemented in the game, it's a really nice collision feature where the sensor returns an input when colliding with another object, but does not interfere with the game, this was very useful wanting to check the characters progress up the platforms, by adding a counter with the sensor which was used to calculate the score. 

    One of the downsides of pymunk was that I could not remove and put bodies, shapes into the surface when the loop was already running, because it caused major performance issue in the game. But the good news is that it also forced me to think of a lot of work arounds that ended up making the game lighter. I always planned on creating the platforms inside a list to keep them all together, this would not only be easier to manage them all at once, but would save memory when using the collision handler. The first plan was to remove the platforms as they left the screen and add new one on the top of the screen, but like I previously mention pymunk has major performance issues when removing and adding its objects while the game loop is running, and according to it's documentation can cause a lot of unexpected results. From my time doing this project I've learned that when running the program surprises are the last thing you want. For the workaround the issue of not being able to remove and add the platforms, I came up with the idea of reusing the platforms, by moving them back to the top(end of the list) when they had passed the total screen height. 
    
    Great problem solved! but now how to count the number of passed platforms? well I thought I would be a bronceeeze after this, if only I knew what was ahead of me. Since the platforms were pre-spawned before the game started counting them  was easy, but they wouldn't count more than once, because even tho it looked like we were using new platforms when they moved up the list knew that it had already counted.

    This project was redesigned 3 times, the first time was to create a basic concept as I was unfamiliar with both libraries and had to pass an extensive time reading through the docs(which I also didn't know how to fully read) and watch a lot of videos and tutorials of just how to use the libraries. I didn't mention earlier but my final project was going to be something completly differnet, but it used these two libraries, I started with wanting to create a traffic light simulation that was controlled by ai. Which was going well, but the progress was taking forevery since, well, I've never programmed before aside from the cs50p coursework. My goal is to learn Artificial Intellegence and to do that I needed finish this project, so with a heavy heart I decided to do somethinig that I thought I was in the scope of my capabilities from all the 10 weeks of lessons. I spent a lot of time doing random pygame tutorials of mini games to get a feel of the library, and that we I ran into the physics engine simulator. Pygame was chosen because it was a more begginer friendly gui library and pymunk was chosen because I thought it was really cool (don't judge), to make this game pygame could have been the only library I used, but I wanted to learn a broader scope of libraries when making this project and it really pushed me to learn how to read different types of documentations(I don't know if pymunk was the best for that as in its python documentation it tells you to read the chimpmunk doc as well for reference, which would be nice if I understood C). 

    One of the biggest things I enjoyed in the cs50p lessons was the OOP, I love organizing stuff and creating databases and lists. The great thing about pygame that I learned as the game developed is that it's a great way to learn how to use OOP on a beginner level. While doing this project I was wathed more videos than cs50p lessons there were, and I absolutely fell in love with the astethic of creating clean, easy to read and pretty to look at code. Of course that isn't to tell I kept in mind that just because a code looks pretty and clean doesn't mean it's good. In fact as clean as I think my code is, I know there are better ways to do it and organize it, and I'll see that when I make future projects. But I'm pretty proud of how my design came with only the basic tools of programming in python. 

    To the design! As I said my first design was more of prototype to get the feel of the game, and I can't lie with pymunk it was super fast to create a basic concept of what I wanted. I had a list of things I wanted to have in the game and how they would interact from the getgo, but a lot of other requirements started arising as the game progressed, and I quickly learned that my initial design idea was the best for what I was making. Shoutout to the youtuber ArjanCodes for making a pdf of what to keep in mind when designing a program, one thing he mentioned stuck to me and helped a lot. He said when making a program always be ready and open to throwing your code away, don't get attached to it. By doing that little by little I was able to hold onto the principle of what the code was doing and rewritting the whole thing from scratch. 

    The second redesign was the implementation of classes, woohoo OOP! From many videos I watched the worst thing about OOP is the dependency issue which leads to coupling. Which I think is very easy to have when you only know the basics of OOP, with that in mind and the requirements for the final project which helped with this I decided to go with dependency injection to avoid couple. I also liked the idea of dependency injection as I could move and change things in my class without affecting the other classes. So in this new redesign I made a class for every single thing in an individual file and then brought them all together inside the main file and main function. I thought I had solved everything, until I stopped to look at my main file, there were over 10 imports! and even tho you could read, it looked ugly and nothing like the videos I had been watching. The were also the fact that I was retyping a lot of the values so that a certain class could use, and to top it all, inserting sprites in this design was impossible! so I decided with a very heavy heart(mostly because I thought I was almost done with the code) to redesign. I actually spent two days on this last and final redesign! which even tho I like it I can see that it can still be made even better. But I need to eventually finish my project, so I made a list of serveral things that would be important and decided on a priority level if it was worth changing it.

    The final and current redesign I thought really hard about it, I made a graph of all the files I would need and the order to place them. I also spent quite sometime drawing out all the classes that would require some form of dependency injection or another form of very specific dependency in the value that was store in another class. I thought about creating a parent file, and opted out once I made a list of all my classes and saw what each class had similar with each other. The reason I decided not to was because the number of values that each class and function needed that were similar to each other didn't go over two each, like the drawing I'll be showing. The dependencies were if not all mostly constant variables, which gave me the idea of creating a settings.py file with all the constant vairables, these ranged from rgb colours, screen width, height, font, fps, clock, the platform number. On top of those I decided to just add the rest of the constant variable I thought would go with the settings such as the gravity, damping(physics simulater stuff), etc. That way when writing everything down on my files and main file, there wouldn't be a mixture of numbers and word variables with numbers attached to them. One thing I also put a lot of time in was deciding the name of the every variable, class, function and method. That way even though the person reading the class wouln't know the actual numbers they would be able to understand what was being done, like displaying a formula and what values are being stored in them e.g. distance = speed/time, see you don't know the actual values of speed and time, but you can clearly see that the distance is being calculated by dividing them both. 
    
    When making my game one thing I struggled with was if I should make my game fullscreen or windowed and if the objects and physics simulator would scale nicely. Spoiler, it didn't. I started by whole game design the first time on a 640x480 resolution, and did not want to scale that by adding endless if statements and scaling individually depending on the screen of the user. So I made the scale_object.py file which would be similar to the settings.py but would store all the constant variables of all the objects in my game with the percentage it should be scaling in relation to the screen resolutions. It worked really well! And I was able to again use these constant variables into my other classes depending of where its value was needed to calulate something. Now I'm sure that are better ways to design what I did, but with how much time I have set for myself, and how much stuff was left, this wasn't a big priority to modify as it was very efficient in keeping all my constant values in one place. This was not only easy to use but when resetting the game I just had to recall these constant variables. 

    The next priority of my redesign and one I wanted to prioritize was to not have so many imports in my main file, I wanted my main file to be obvious that it was meant to run the games in the loop, and be responsible for starting and ending the program. So with that idea I create a GameSetup and a GameManagement class, I don't know if there names are too similar but the GameSetup was meant to create the space(for the physics simulator) and to add the bodies and shapes of the character and platform. Its a verty short class but holds all creation of everything we will see in the game. My longest class and one I thought of breaking it up into smaller parts but decided not to was the GameManagement, which is literally what the name says, it's where I all my classes and gamesetup and use the methods in each class that needs to interact with each other in one place, such as the player interaction with the paltform or by restricting the player from jumping while it's in the air with the collision method that checks if character is in the air. This class would be the heart of where everything is assigned with each other and then neatly called in one method in the a specific order for the game to run. It came out a little long, as the GameManagement had a couple of methods of its own, but overall made it much easier to see where and what methods from what class where interaction with each other without the classes having to actually know about each other. The best part was that I could now add the sprites to the objects! and the GameManagement made it possible to add them to the scroll effect!

    As per the requirements of having 3 functions on the same indentation level as the main in the main file, I created the menu surface, control_menu surface and the start_game functions in the main file wihout cluttering the main file just like I wanted to! Now that we are here you might be thingking, what about the test! and worry not, the first thing I thought about and made when creating the last redesign was the test file, but it not only forced me to thing how I would test most of my classes, but a clearer path of making them as independent as possible! The files were made to run perfectly together when setup in the GameManagement, but that it not to say they can't be run individually in a physics space and pygame surface. Their statements can also be test, I had a very hard time graping the concept of how to make test files and still do, I don't know where to start with wording, specially because pytest isn't very gui test friendly, but it forced me once again to think of other ways to test my methods and functions.

    A final part of my final design was the implementation of packages, I had already thought of making it so that there were less files in the root, and slowly reading and searching the python docs on how to create modules, packages and libraries for a small game like this one it was decided to create a module for the character as its movements and jump where closely related, then with the module the package was created with all the components that would be called and set in the GameMangement class later on. Making the whole design easy to read and understand(as far as I can tell)